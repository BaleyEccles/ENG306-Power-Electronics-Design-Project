#+title: ENG306 - Power Electronics - Converter Design Report
#+AUTHOR: Baley Eccles - 652137 and Tyler Robards - 651790
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage[a4paper, margin=2cm]{geometry}
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+LATEX_HEADER_EXTRA: \usepackage{fontspec}
#+LATEX_HEADER_EXTRA: \setmonofont{Iosevka}
#+LATEX_HEADER_EXTRA: \setminted{fontsize=\small, frame=single, breaklines=true}
#+LATEX_HEADER_EXTRA: \usemintedstyle{emacs}
#+LATEX_HEADER_EXTRA: \usepackage{float}
#+LATEX_HEADER_EXTRA: \usepackage[final]{pdfpages}
#+LATEX_HEADER_EXTRA: \setlength{\parindent}{0pt}
#+LATEX_HEADER_EXTRA: \setlength{\parskip}{1em}
#+LATEX_HEADER: \usepackage[style=apa, backend=biber]{biblatex}
#+LATEX_HEADER: \addbibresource{References.bib}
#+LATEX_HEADER: \DeclareLanguageMapping{english}{english-apa}

\newpage
* Introduction
This report outlines the design and performance analysis of a power converter, which consists of a rectifier stage feeding into a buck converter stage. The design of this converter will require analysis into its efficiency, harmonics and regulation capabilities.

The project aims to design a converter capable of handling a maximum AC input of $32VRMS$ and providing a DC output of $12V$ with less than $0.7\%$ voltage ripple. This report details the specifications, calculations, and component selection that informed the design process, including the rectifier and buck converter stages. Furthermore, simulations were conducted using PLECS to validate the design and identify its performance under various load conditions and input voltages.

In addition to the design aspects, this report presents a thorough performance analysis of the constructed converter, evaluating its output voltage regulation, efficiency, and harmonic distortion. The findings highlight both the successes and failures in the design and testing phases, providing valuable insights into the practical implications of power converters. The produced board can be seen in Figure \ref{fig:BOARD}.

#+ATTR_LATEX: :placement [H] :options angle=90
#+CAPTION: Designed Converter Running An Arduino Uno \label{fig:BOARD}
[[./IMG20251016100928.jpg]]

* Design

** Specifications
#+ATTR_LATEX: :placement [H] :align |c|c|
#+CAPTION: Converter Specifications \label{tab:SPEC_DATA}
|-------------------------------+-----------|
| Max AC input voltage ($VRMS$) |        32 |
|-------------------------------+-----------|
| Min AC input voltage ($VRMS$) |        20 |
|-------------------------------+-----------|
| Max DC output current ($A$)   |         5 |
|-------------------------------+-----------|
| Min DC output current ($A$)   |       0.5 |
|-------------------------------+-----------|
| Voltage ripple                |      0.7% |
|-------------------------------+-----------|
| DC output voltage ($V$)       | 12\pm0.03 |
|-------------------------------+-----------|

** Calculations And Component Selection
*** Rectifier
The output of the rectifier must be greater than $12V$ for all load and input voltage conditions for the buck converter stage to work. This means that voltage ripple for $V_m = 32\sqrt{2}V$ must be less than $\Delta V_o = V_m - V_{min} = 32\sqrt{2} - 12 = 33.3V$ and for our lowest voltage of $V_m = 20\sqrt{2}V$ the voltage ripple must be less than $\Delta V_o = 16.3V$.

If we assume that the frequency is going to be $50Hz$ (Australia mains AC frequency), then we can calculate a capacitance for each load of $24\Omega$ and $2.4\Omega$:
\begin{align*}
\Delta V_o &= \frac{\pi V_m}{2\pi f R C} \\
\Rightarrow C &= \frac{\pi V_m}{2\pi f R \Delta V_o} \\
C_1 &= \frac{\pi\cdot 32\sqrt{2}}{2\cdot \pi\cdot 50\cdot 24\cdot 33.3}  = 566.3\mu F\\
C_2 &= \frac{\pi\cdot 32\sqrt{2}}{2\cdot \pi\cdot 50\cdot 2.4\cdot 33.3} = 5662.5\mu F\\
C_3 &= \frac{\pi\cdot 20\sqrt{2}}{2\cdot \pi\cdot 50\cdot 24\cdot 16.3}  = 723.0\mu F\\
C_4 &= \frac{\pi\cdot 20\sqrt{2}}{2\cdot \pi\cdot 50\cdot 2.4\cdot 16.3} = 7230.1\mu F\\
\end{align*}

The above calculations do not consider the input of the impedance of the LM5117. It is reasonable to assume that the filtering capacity of the rectifier will be less than this. If it is found that this is not the case a higher order filter could be considered, this would include adding an inductor in series with the filter.

It was decided that a $1000\mu F$ capacitor was going to be used as the filter. This was expected to provided enough filtering to ensure nominal operation without sacrificing complexity of design a higher order filter.

*** Buck Converter
The switching frequency was decided to be $f_{SW} = 235kHz$, as the provided design already came loaded with a $22k\Omega$ resistor. If this needed to be changed the following equation could have been used, which was obtained from the data sheet for the LM5117 (\cite{LM5117_Datasheet}, p. 15).
\[R_T = \frac{5.2\times 10^9}{f_{SW}} - 948\]

"Generally, higher frequency applications are smaller but have higher losses" (\cite{LM5117_Datasheet}, p. 25). Given that efficiency is not a required metric for our design then going with a higher switching frequency will provide better performance.

Next the output inductor ($L_O$) can be calculated, this is dependent on the inductor ripple current. The data sheet states that between 20% and 40% of the maximum load current is generally good, this means that our inductor ripple current should be between $20\%\cdot 5 = 1A$ and $40\%\cdot 5 = 2A$. 

\begin{align*}
L_O &= \frac{V_o}{\Delta I_L\cdot f_{SW}}\left(1 - \frac{V_o}{V_{\textrm{in},\max}}\right) \\
L_{O,1} &= \frac{12}{1\cdot 235\times10^3}\left(1 - \frac{12}{32\sqrt{2}}\right) = 37.5 \mu H \\
L_{O,2} &= \frac{12}{2\cdot 235\times10^3}\left(1 - \frac{12}{32\sqrt{2}}\right) = 18.8 \mu H \\
\end{align*}

A $47\mu H$ inductor was chosen, as this would reduce the burden on the output filtering capacitors, thus leading to a lower output  voltage ripple. This allows us to calculate a new indcutor ripple current as follows:

\begin{align*}
\Delta I_L &= \frac{V_o}{L_O\cdot f_{SW}}\left(1 - \frac{V_o}{V_{\textrm{in},\max}}\right) \\
\Delta I_L &= \frac{12}{47\times10^{-6}\cdot 235\times10^3}\left(1 - \frac{12}{32\sqrt{2}}\right) \\
\Rightarrow \Delta I_L &= 0.8A
\end{align*}

Next the output capacitance can be found, from the specifications the output ripple must be less than $0.7\%\cdot12 = 84mV$. These equations are taken from the data sheet (\cite{LM5117_Datasheet}, p. 29).

\begin{align*}
\Delta V_o &\approx \frac{\Delta I_L}{8\cdot f_{SW}\cdot C_o} \\
\Rightarrow C_o &\approx \frac{\Delta I_L}{8\cdot f_{SW}\cdot \Delta V_o} \\
C_o &\approx \frac{0.8}{8\cdot 235\times10^3\cdot 84\times10^{-3}} \\
C_o &\approx 5\mu F
\end{align*}

A $515\mu F$ output capacitance was already provided in the design, so adding any extra capacitance was going to be overkill. Given these calculations it is expected that the output voltage ripple will be:

\begin{align*}
\Delta V_o &\approx \frac{\Delta I_L}{8\cdot f_{SW}\cdot C_o} \\
\Delta V_o &\approx \frac{0.8}{8\cdot 235\times10^3\cdot 515\times10^{-6}} \\
\Delta V_o &\approx 826\mu V
\end{align*}

The input capacitance can be calculated, as we know the input voltage ripple from the rectifier design. The input voltage ripple will be considerable, so adding these capacitors will have a minimal effect.

\begin{align*}
\Delta V_{\textrm{in}} &= \frac{I_{out}}{4\cdot f_{SW}\cdot C_{in}} \\
\Rightarrow C_{in} &= \frac{I_{out}}{4\cdot f_{SW}\cdot \Delta V_{\textrm{in}}} \\
C_{in,1} &= \frac{0.5}{4\cdot 235\times10^3\cdot 33.3} = 16.0nF\\
C_{in,2} &= \frac{5}{4\cdot 235\times10^3\cdot 33.3} = 159.7nF\\
C_{in,3} &= \frac{0.5}{4\cdot 235\times10^3\cdot 16.3} = 32.6nF\\
C_{in,4} &= \frac{5}{4\cdot 235\times10^3\cdot 16.3} = 326.3nF\\
\end{align*}

Three $3.3\mu F$ capacitors were added in parallel to the input, these will reduce the high frequency noise from the input and rectification.

** Output Voltage
During testing it was noticed that the output voltage was considerably off of the desired $12V$, it was at about $10.3V$. Looking at the data sheet for the LM5117 it can be seen that the output voltage is defined by the following equation.

\[V_o = 0.8\left(\frac{R_{18} + R_{17}}{Rb_{16}||R_{16}} + 1\right)\]

From the above equation it can be seen that the expected output voltage was going to be $V_o = 10.56V$. This lines up with what was measured during testing, however this is not the voltage that is desired. It was decided that $R_{16}$ and $Rb_{16}$ were going to be replaced with $R_{16} = 5.1k\Omega$ and $Rb_{16} = 330\Omega$ as these were available and would provide the smallest amount of voltage error and allow for the largest amount of resistor error, the code that produced this result can be seen in Appendix A.

* Modelling And Simulation Analysis
The design was simulated in PLECS before being built, this allowed for revision of our design. The PLECS model can be seen in Figure \ref{fig:PLECS_SCHEMATIC}, it uses the main component values as described in the component selection section.

The LM5117 does not exist in PLECS so a PID control loop had to be implemented, this control loop will not perform nearly as well as the LM5117 because the LM5117 is specifically designed for this use case, whereas designing the PID for this would take a considerable amount of time.

#+ATTR_LATEX: :placement [H]
#+CAPTION: PLECS Model \label{fig:PLECS_SCHEMATIC}
[[./Simulation_Schematic.png]]

The best case can be seen in Figure \ref{fig:PLECS_BEST_CASE}, it has $V_{\textrm{in}} = 32V\ RMS$ and a $24\Omega$ load. It can be seen that the voltage ripple is approximately $0.5V$, this is more than the acceptable voltage ripple and is due to the PID being tuned poorly. The code that produced this plot can be seen in Appendix B.

#+ATTR_LATEX: :placement [H]
#+CAPTION: PLECS Best Case Output Voltage \label{fig:PLECS_BEST_CASE}
[[./ENG306_Design_Best_Case_Sim.png]]

The worst case can be seen in Figure \ref{fig:PLECS_WORST_CASE}, it has $V_{\textrm{in}} = 20V\ RMS$ and a $2.4\Omega$ load. It can be seen that the voltage ripple is approximately $7V$, once again this is more than the acceptable voltage ripple and is due to the PID. The code that produced this plot can be seen in Appendix B.

#+ATTR_LATEX: :placement [H]
#+CAPTION: PLECS Worst Case Output Voltage \label{fig:PLECS_WORST_CASE}
[[./ENG306_Design_Worst_Case_Sim.png]]

To verify that the LM5117 will run the voltage at the input to the buck converter stage must be greater than the desired output voltage of $12V$, this will allow us to know if the rectifier output filter needs to change. For the worst case this can be seen in Figure \ref{fig:PLECS_RECTIFIER}, and the code that produced it can be seen in Appendix B. As can be seen the voltage remains above $12V$ for all time, this means that the rectifier filter should work.

#+ATTR_LATEX: :placement [H]
#+CAPTION: PLECS Rectifier Output Voltage \label{fig:PLECS_RECTIFIER}
[[./ENG306_Design_Rectifier_Output_Sim.png]]

The simulation performs poorly, it does not meet any of the required metrics, however this is expected and is due to the insufficient control loop. According to all the previous calculations the design should meet the required specifications.

* Converter Performance Analysis
The following table (Table \ref{tab:PREFORMANCE_DATA}) describes the performance of the built converter for the required metrics. The code that produced this table and the figures in this section can be seen in Appendix C.

#+ATTR_LATEX: :placement [H] :align |c|c|c|c|c|c|c|
#+CAPTION: Converter Performance At Various Conditions \label{tab:PREFORMANCE_DATA}
|--------------------+-----------------+---------------+----------+-------------+-------------+--------------|
| $V_{\textrm{in}}$ RMS ($V$) | Load ($\Omega$) | Ripple ($mV$) | Ripple % | $V_{\max}$ ($V$) | $V_{\max}$ ($V$) | $V_{\textrm{mean}}$ ($V$) |
|--------------------+-----------------+---------------+----------+-------------+-------------+--------------|
|                 32 |               0 |         25.40 |    0.213 |       11.95 |       11.92 |        11.93 |
|--------------------+-----------------+---------------+----------+-------------+-------------+--------------|
|                 32 |              22 |         35.15 |    0.295 |       11.90 |       11.86 |        11.88 |
|--------------------+-----------------+---------------+----------+-------------+-------------+--------------|
|                 32 |             2.5 |        293.00 |    2.484 |       11.94 |       11.65 |        11.79 |
|--------------------+-----------------+---------------+----------+-------------+-------------+--------------|
|                 23 |              25 |         41.02 |    0.344 |       11.94 |       11.90 |        11.92 |
|--------------------+-----------------+---------------+----------+-------------+-------------+--------------|
|                 20 |             2.5 |      10644.50 |  116.908 |       11.90 |        1.26 |         9.10 |
|--------------------+-----------------+---------------+----------+-------------+-------------+--------------|

From the last row in Table \ref{tab:PREFORMANCE_DATA} it can clearly be seen that the required metrics were not fully met, the plot of the acquired data for this can be seen in Figure \ref{fig:2_5_20VRMS}. For this specific case the input voltage was $20VRMS$ and the load was $2.5\Omega$, this is the worst possible case for the converter. It preformed this poorly because the LM5117 was supplied with less than $12V$, this caused the converter to stop working for various parts of the cycles which can be seen in Figure \ref{fig:2_5_20VRMS}. This could have been fixed by improving the rectifier output filter, as this provides the voltage to the LM5117.

#+ATTR_LATEX: :placement [H]
#+CAPTION: $2.5\Omega$ Load With $20VRMS$ Input Voltage Output Voltage Plot \label{fig:2_5_20VRMS}
[[./ENG306_Design_2.5_Ohm_Load_V_in_20_VRMS.png]]

A more typical voltage plot can be seen in Figure \ref{fig:22_32VRMS}, it has a mean voltage of $11.88V$ and a ripple of $35.15mV$. This case fits the required specifications, with an exception of the mean voltage which is because of the error in the resistors $R_{16}$ and $Rb_{16}$. Due to time constraints it was decided that the acquired mean voltage was good enough, if more time was available the two sense resistors could have been changed for more accurate ones.

#+ATTR_LATEX: :placement [H]
#+CAPTION: $22\Omega$ Load With $32VRMS$ Input Voltage Output Voltage Plot \label{fig:22_32VRMS}
[[./ENG306_Design_22_Ohm_Load_V_in_32_VRMS.png]]

During testing the converter was tested on a laptop and an Arduino Uno. The converter was able to power the Arduino Uno, it did so with very little effort, this can be seen in Figure \ref{fig:BOARD}. However, the laptop could not be powered, this was due to the laptop requiring $20V$, not $12V$. If a laptop required $12V$ was available it is believed that the converter would have been able to power it.

* Efficiency Analysis
Because the design uses a high switching frequency it is expected that the efficiency will be relatively low. A higher frequency causes the switches to activate and deactivate more often, leading to more losses (\cite{LM5117_Datasheet}, p. 25).

The main losses are going to come from the rectifier and LM5117. The rectifier is attached to the higher voltage side and the LM5117 has many switches and components that will effect the efficiency.

The diodes in the rectifier experience three types of losses, forward power loss $P_F$, reverse power loss $P_R$ and reverse recovery loss $P_{RR}$. The losses are equal for each diode, so we only need to calculate the loss for one cycle and then multiply the result by two and then divide by two to account for the each diode being on for only half the time.

For the worst case situation the reverse losses can be calculated as so:
\begin{align*}
P_R &= V\cdot I \\
P_R &= 20\cdot 0.548 \\
P_R &= 10.96
\end{align*}

Similarly the forward losses can be calculated to be $P_F = 0.603W$, using $1.1V$ for the forward voltage (\cite{KBP3005G_Datasheet}, p. 2).

The reverse recovery loss can be ignored as this would be minimal compared to the forward and reverse recovery losses. This gives a total power loss for the rectifier stage of:
\begin{align*}
P_T &= \frac{2\cdot P_R}{2} + \frac{2\cdot P_F}{2} \\
P_T &= \frac{2\cdot 10.96}{2} + \frac{2\cdot 0.603}{2} \\
P_T &= 11.563W
\end{align*}

The buck converter stage loss is harder to calculate. The main losses in this stage will come from the switching of the MOSFETS, the data sheet sates a worst case of $R_{DS_{on}} = 12m\Omega$ (\cite{MOSFET_Datasheet}, p. 6). This allows us to calculate a power loss of:

\begin{align*}
P_{MOSFET} &= I_{DS}^2R_{DS_{on}} \\
P_{MOSFET} &= 5^2\cdot12\times10^{-3} \\
P_{MOSFET} &= 0.3W
\end{align*}

All of the other losses will be minimal, as they are related to the control loop which will draw very little current. Thus, these losses will be ignored.

This allows us to calculate an overall efficiency of the converter.

\begin{align*}
\eta &= \frac{P_{in}}{P_{out}} \\
\eta &= \frac{P_{out} - P_{loss}}{P_{out}} \\
\eta &= \frac{5\cdot12 - (11.563 + 0.3)}{5\cdot12} \\
\eta &= 80.2\%
\end{align*}

Table \ref{tab:EFFICENCY_DATA} shows the efficiency of the converter for various input voltages. The data was recorded by changing the input voltage while having a constant load of $25\Omega$. This provides a relation from input voltage to efficiency.

#+ATTR_LATEX: :placement [H] :align |c|c|c|c|c|c|c|
#+CAPTION: Efficiency Data For Various Input Voltages With A Load of $25\Omega$ \label{tab:EFFICENCY_DATA}
|------------------+---------------+--------------+---------------+----------------+------------------+----------------|
| $V_{in,rms}$ ($V$) | $I_{in}$ ($mA$) | $P_{in}$ ($W$) | $V_{out}$ ($V$) | $I_{out}$ ($mA$) | $P_{out}$ ($W$) | Efficiency (%) |
|------------------+---------------+--------------+---------------+----------------+------------------+----------------|
|               32 |           256 |         8.19 |        11.914 |            482 |            5.742 |           70.1 |
|------------------+---------------+--------------+---------------+----------------+------------------+----------------|
|               29 |           280 |         8.12 |        11.914 |            482 |            5.742 |           70.7 |
|------------------+---------------+--------------+---------------+----------------+------------------+----------------|
|               26 |           308 |         8.01 |        11.914 |            482 |            5.742 |           71.7 |
|------------------+---------------+--------------+---------------+----------------+------------------+----------------|
|               23 |           351 |         8.07 |        11.914 |            482 |            5.742 |           71.2 |
|------------------+---------------+--------------+---------------+----------------+------------------+----------------|
|               20 |           387 |         7.74 |        11.916 |            482 |            5.743 |           74.2 |
|------------------+---------------+--------------+---------------+----------------+------------------+----------------|

The plot in Figure \ref{fig:EFF} (code seen in Appendix E) relates the input voltage to the efficiency. This gives insight into how the converter uses the power from the source, as the input voltage goes up the efficiency goes down. This is because the rectifier stage has the main losses which can be seen in the previous calculations.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Input Voltage Vs Efficency Plot \label{fig:EFF}
[[./ENG306_Design_Efficency_Plot.png]]

The power analyser was used with a $25VRMS$ input voltage and a $2.4\Omega$ load, this gave $P_{in} = 64.32W$ and $P_{out} = 52.44$, which gives an efficiency of $82\%$. This and the previous data shows that the efficiency of the converter is highly dependent on the load and input voltage, for lower loads and input voltages the converter is more efficient.

* Harmonics
From Figure \ref{fig:HARMONICS} it can be seen that the harmonics have a general decreasing trend which is to be expected. The second harmonic has a larger magnitude than the fundamental; this is just an artefact of the data collected. The code that produced this plot can be seen in Appendix D.

#+ATTR_LATEX: :placement [H]
#+CAPTION: $2.5\Omega$ Load With $20VRMS$ Input Voltage Fourier Transform \label{fig:HARMONICS}
[[./ENG306_Design_Harmonics.png]]

The power analyser was used in testing, it gave a third harmonic value of 62.3% and a total harmonic distortion of 70.9%. The third harmonic from the Fourier spectrum is about 53.6% and the total harmonic distortion can be calculated to be 40.6%, the calculation can be seen below. The total harmonic distortion from the Fourier spectrum is worse than the power analyser one, this is because the Fourier spectrum was taken from the worst case, whereas the power analyser case was operating under better conditions.

\begin{align*}
THD &= \frac{\sqrt{I_{rms}^2 - I_{1,rms}^2}}{I_{1,rms}} \\
THD &= \frac{\sqrt{\sqrt{1 + 0.522^2 + 0.02^2 + 0.04^2 + 0.19^2 + 0.03^2 + 0.19^2 + 0.01^2 + 0.063^2 + 0.077^2} - 1^2}}{1^2} \\
THD &= 0.406 = 40.6\%
\end{align*}


* No Load Analysis
For no load the inductor voltage can be seen in Figure \ref{fig:INDUCTOR}, it shows the inductor voltage over time. Voltage peaks occur at equal intervals at a rate of $f = \frac{1}{4.5\times10^{-6}} \approx 235kHz$ which is the switching frequency, so every time the LM5117 switches the MOSFET the inductors voltage peaks. This is because the indcutor encounters a large change in current, this can be confirmed by looking at the equation for the inductor: $v = L \frac{di}{dt}$.

#+ATTR_LATEX: :placement [H]
#+CAPTION: No Load Inductor Voltage \label{fig:INDUCTOR}
[[./Data/Inductor_Voltage.PNG]]


* Regulation Capability
Load regulation can be calculated using $LR = \frac{V_{NL} - V_{FL}}{V_{FL}}$, where $V_{NL}$ is the no load voltage and $V_{FL}$ is the full load voltage (\cite{Load_Regulation}). Using the data in Table \ref{tab:PREFORMANCE_DATA} the load regulation can be calculated as follows.

\begin{align*}
LR &= \frac{V_{NL} - V_{FL}}{V_{FL}} \\
LR &= \frac{11.93 - 11.88}{11.88} \\
LR &= 0.421\%
\end{align*}

Likewise, the line regulation can be calculated using $LR = \frac{V_{HL} - V_{LL}}{V_{LL}}$, where $V_{HL}$ is the voltage at high line voltage and $V_{LL}$ is the voltage at low line voltage (\cite{Load_Regulation}). Once again, this can be calculated using the data in Table \ref{tab:PREFORMANCE_DATA} and data collected from power analysis, as shown in the following calculations.

\begin{align*}
LR &= \frac{V_{HL} - V_{LL}}{V_{LL}} \\
LR &= \frac{11.91 - 11.89}{11.89} \\
LR &= 0.168\%
\end{align*}

This shows very good regulation capabilities, the converter is capable of maintaining a close to nominal voltage for maximum load and minimum line voltage. In other words, the converter output voltage changes very little when changing the loading condition and input voltages.

* Conclusion
In this report, we successfully designed and analysed a power converter capable of providing a regulated DC output of 12V with minimal voltage ripple. Challenges related to output voltage regulation were faced, the converter performed well under various load conditions, as validated by both PLECS simulations and real-world testing.

The converter's performance metrics were met under most circumstances; the output voltage ripple met acceptable limits under specific load conditions, significant deviations occurred at high loads, mainly due to an inadequate rectifier filter. The implemented buck converter efficiently regulated output voltage with a ripple of less than 0.3%, showcasing strong load and line regulation capabilities. However, the overall efficiency of the converter was moderate, primarily impacted by high switching frequencies and losses associated with the rectifier.

Future work could improve the converter's performance by improving the rectifier filter and utilising higher precision resistors to ensure the output voltage remains in the specified range. Despite its limitations, the design demonstrates valuable insights into power converter design and operation, emphasising the balance between performance, complexity, and efficiency in real-world applications.

\newpage
* Appendix A - R16 And Rb16 Code

#+BEGIN_SRC octave :exports both :results output :session R16_Rb16 :eval no
clc;
clear;
close all;

if exist('OCTAVE_VERSION', 'builtin')
 set(0, "DefaultLineLineWidth", 2);
 set(0, "DefaultAxesFontSize", 25);
 warning('off');
end

R_18 = 22.4;
R_17 = 4.345e3;
R_FB1 = 338.7;
V_out = 12;

R_FB2 = R_17 + R_18;
R_FB1 = R_FB2/(V_out/0.8 - 1);

% Avalible resistors
R_vals = [1e3, 10e3, 1, 1.2, 1.5, 2, 2.7, 3.3, 4.3, 5.1, 6.8, 8.2, 10, 12, 15, 20, 27, 33, 43, 51, 68, 82, 100, 120, 150, 200, 270, 330, 430, 510, 680, 820, 1.2e3, 1.5e3, 2e3, 2.7e3, 3.3e3, 4.3e3, 5.1e3, 6.8e3, 8.2e3, 12e3, 15e3, 20e3, 27e3, 33e3, 43e3, 51e3, 68e3, 82e3, 100e3, 120e3, 150e3, 200e3, 270e3, 330e3, 430e3, 510e3, 680e3, 820e3, 1e6, 2e6];
R16 = R_vals;
Rb16 = 1./(1./R_FB1 - 1./R16);

tol = 2.5/100; % Tolerance of 2.5%
for idx = 1:length(R16)
  for jdx = 1:length(R_vals)
    up_bound = R_vals(jdx) + R_vals(jdx)*tol;
    low_bound = R_vals(jdx) - R_vals(jdx)*tol;
    if (Rb16(idx) >= low_bound && Rb16(idx) <= up_bound)
      percent_error = 100*abs(R_vals(jdx) - Rb16(idx))/Rb16(idx);
      V_out_true = 0.8*(R_FB2/(1/(1/R16(idx) + 1/R_vals(jdx))) + 1);
      
      sprintf("For a resistor error of %f%% choose:", percent_error)
      sprintf("R16 = %.0f and ideally Rb16 = %.3f, but select Rb16 = %.0f from the book.\nThis will give an output voltage of %.3f and 12 - Vo = %.4f", R16(idx), Rb16(idx), R_vals(jdx), V_out_true, 12 - V_out_true)
      sprintf("\n")
      
    end
  end
end
#+END_SRC

#+RESULTS:
#+begin_example
ans = For a resistor error of 2.483762% choose:
ans = R16 = 10000 and ideally Rb16 = 322.002, but select Rb16 = 330 from the book.
This will give an output voltage of 11.737 and 12 - Vo = 0.2630
ans = 

ans = For a resistor error of 2.072306% choose:
ans = R16 = 510 and ideally Rb16 = 803.352, but select Rb16 = 820 from the book.
This will give an output voltage of 11.912 and 12 - Vo = 0.0883
ans = 

ans = For a resistor error of 1.288873% choose:
ans = R16 = 820 and ideally Rb16 = 503.510, but select Rb16 = 510 from the book.
This will give an output voltage of 11.912 and 12 - Vo = 0.0883
ans = 

ans = For a resistor error of 2.006113% choose:
ans = R16 = 1200 and ideally Rb16 = 421.543, but select Rb16 = 430 from the book.
This will give an output voltage of 11.837 and 12 - Vo = 0.1630
ans = 

ans = For a resistor error of 1.890657% choose:
ans = R16 = 4300 and ideally Rb16 = 336.359, but select Rb16 = 330 from the book.
This will give an output voltage of 12.200 and 12 - Vo = -0.2002
ans = 

ans = For a resistor error of 0.686827% choose:
ans = R16 = 5100 and ideally Rb16 = 332.282, but select Rb16 = 330 from the book.
This will give an output voltage of 12.073 and 12 - Vo = -0.0727
ans = 

ans = For a resistor error of 0.930820% choose:
ans = R16 = 6800 and ideally Rb16 = 326.957, but select Rb16 = 330 from the book.
This will give an output voltage of 11.901 and 12 - Vo = 0.0986
ans = 

ans = For a resistor error of 1.759371% choose:
ans = R16 = 8200 and ideally Rb16 = 324.294, but select Rb16 = 330 from the book.
This will give an output voltage of 11.814 and 12 - Vo = 0.1863
ans =
#+end_example

\newpage
* Appendix B - PLECS Plots Code

#+BEGIN_SRC octave :exports both :results output :session BEST_CASE_SIM :eval no
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
end

% Best Case
data = csvread('Best_Case.csv', 1, 0);
t = data(:, 1);
t = t - t(1);
v = data(:, 2);

figure;
plot(t, v);
xlim([0, 0.06]);
ylim([11.6, 12.6]);
grid on;
title('Best Case Output Voltage vs Time');
xlabel('Time (s)');
ylabel('Output Voltage (V)');
print -dpng 'ENG306_Design_Best_Case_Sim.png'

% Worst Case
data = csvread('Worst_Case.csv', 1, 0);
t = data(:, 1);
t = t - t(1);
v = data(:, 2);

figure;
plot(t, v);
xlim([0, 0.25]);
ylim([8, 16]);
grid on;
title('Worst Case Output Voltage vs Time');
xlabel('Time (s)');
ylabel('Output Voltage (V)');
print -dpng 'ENG306_Design_Worst_Case_Sim.png'

% Rectifier Output
data = csvread('Rectifier_Output.csv', 1, 0);
t = data(:, 1);
t = t - t(1);
v = data(:, 2);

figure;
plot(t, v);
xlim([0, 0.25]);
ylim([12, 30]);
grid on;
title('Rectifier Output Voltage vs Time');
xlabel('Time (s)');
ylabel('Rectifier Output Voltage (V)');
print -dpng 'ENG306_Design_Rectifier_Output_Sim.png'
#+END_SRC

#+RESULTS:
* Appendix C - Testing Code

#+BEGIN_SRC octave :exports both :results output :session TESTING :eval no
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
 set(0, "DefaultLineLineWidth", 2);
 set(0, "DefaultAxesFontSize", 25);
 warning('off');
end

function [V_ripple, V_ripple_percent, V_min, V_max, V_mean] = voltage_data(t, V)
  Q1 = prctile(V, 25);
  Q3 = prctile(V, 75);
  IQR = Q3 - Q1;
  lower_bound = Q1 - 2 * IQR;
  upper_bound = Q3 + 2 * IQR;
  indices = (V >= lower_bound & V <= upper_bound);
  t = t(indices);
  V = V(indices);

  V_max = max(V);
  V_min = min(V);
  V_ripple = V_max - V_min;
  V_mean = mean(V);
  V_ripple_percent = V_ripple/V_mean*100;
end

data_NL = dlmread('./Data/32RMS_Voltage_output_No_Load.CSV', ',', 1, 0);

t_NL = data_NL(:, 1);
t_NL = t_NL - t_NL(1);
V_NL = data_NL(:, 2);
figure;
plot(t_NL(1:1e4), V_NL(1:1e4));
title("No Load V_{\textrm{in}} = 32 VRMS")
print -dpng 'ENG306_Design_No_Load_V_in_32_VRMS.png'

[NL_V_ripple, NL_V_ripple_percent, NL_V_min, NL_V_max, NL_V_mean] = voltage_data(t_NL, V_NL);
sprintf("NL_V_ripple = %fmV\n", NL_V_ripple*1e3)
sprintf("NL_V_ripple_percent = %f%%\n", NL_V_ripple_percent)
sprintf("NL_V_min = %fV\n", NL_V_min)
sprintf("NL_V_max = %fV\n", NL_V_max)
sprintf("NL_V_mean = %fV\n", NL_V_mean)
sprintf("\n")

data_22_Ohm = dlmread('./Data/32RMS_Voltage_output_22_Ohm.CSV', ',', 1, 0);

t_22_Ohm = data_22_Ohm(:, 1);
t_22_Ohm = t_22_Ohm - t_22_Ohm(1);
V_22_Ohm = data_22_Ohm(:, 2);
figure;
plot(t_22_Ohm(1:1e4), V_22_Ohm(1:1e4));
title("22 Ohm Load V_{\textrm{in}} = 32 VRMS")
print -dpng 'ENG306_Design_22_Ohm_Load_V_in_32_VRMS.png'

[V_ripple_22_Ohm, V_ripple_percent_22_Ohm, V_min_22_Ohm, V_max_22_Ohm, V_mean_22_Ohm] = voltage_data(t_22_Ohm, V_22_Ohm);
sprintf("V_ripple_22_Ohm = %fmV\n", V_ripple_22_Ohm*1e3)
sprintf("V_ripple_percent_22_Ohm = %f%%\n", V_ripple_percent_22_Ohm)
sprintf("V_min_22_Ohm = %fV\n", V_min_22_Ohm)
sprintf("V_max_22_Ohm = %fV\n", V_max_22_Ohm)
sprintf("V_mean_22_Ohm = %fV\n", V_mean_22_Ohm)
sprintf("\n")

data_2_5_Ohm = dlmread('./Data/32RMS_Voltage_output_2.5_Ohm.CSV', ',', 1, 0);

t_2_5_Ohm = data_2_5_Ohm(:, 1);
t_2_5_Ohm = t_2_5_Ohm - t_2_5_Ohm(1);
V_2_5_Ohm = data_2_5_Ohm(:, 2);
figure;
plot(t_2_5_Ohm(1:1e4), V_2_5_Ohm(1:1e4));
title("2.5 Ohm Load V_{\textrm{in}} = 32 VRMS")
print -dpng 'ENG306_Design_2.5_Ohm_Load_V_in_32_VRMS.png'

[V_ripple_2_5_Ohm, V_ripple_percent_2_5_Ohm, V_min_2_5_Ohm, V_max_2_5_Ohm, V_mean_2_5_Ohm] = voltage_data(t_2_5_Ohm, V_2_5_Ohm);
sprintf("V_ripple_2_5_Ohm = %fmV\n", V_ripple_2_5_Ohm*1e3)
sprintf("V_ripple_percent_2_5_Ohm = %f%%\n", V_ripple_percent_2_5_Ohm)
sprintf("V_min_2_5_Ohm = %fV\n", V_min_2_5_Ohm)
sprintf("V_max_2_5_Ohm = %fV\n", V_max_2_5_Ohm)
sprintf("V_mean_2_5_Ohm = %fV\n", V_mean_2_5_Ohm)
sprintf("\n")

data_23_RMS_25_Ohm = dlmread('./Data/23RMS_Voltage_output_25_Ohm.CSV', ',', 1, 0);

t_23_RMS_25_Ohm = data_23_RMS_25_Ohm(:, 1);
t_23_RMS_25_Ohm = t_23_RMS_25_Ohm - t_23_RMS_25_Ohm(1);
V_23_RMS_25_Ohm = data_23_RMS_25_Ohm(:, 2);
figure;
plot(t_23_RMS_25_Ohm(1:1e4), V_23_RMS_25_Ohm(1:1e4));
title("25 Ohm Load V_{\textrm{in}} = 23 VRMS")
print -dpng 'ENG306_Design_25_Ohm_Load_V_in_23_VRMS.png'

[V_ripple_23_RMS_25_Ohm, V_ripple_percent_23_RMS_25_Ohm, V_min_23_RMS_25_Ohm, V_max_23_RMS_25_Ohm, V_mean_23_RMS_25_Ohm] = voltage_data(t_23_RMS_25_Ohm, V_23_RMS_25_Ohm);
sprintf("V_ripple_23_RMS_25_Ohm = %fmV\n", V_ripple_23_RMS_25_Ohm*1e3)
sprintf("V_ripple_percent_23_RMS_25_Ohm = %f%%\n", V_ripple_percent_23_RMS_25_Ohm)
sprintf("V_min_23_RMS_25_Ohm = %fV\n", V_min_23_RMS_25_Ohm)
sprintf("V_max_23_RMS_25_Ohm = %fV\n", V_max_23_RMS_25_Ohm)
sprintf("V_mean_23_RMS_25_Ohm = %fV\n", V_mean_23_RMS_25_Ohm)
sprintf("\n")

data_20_RMS_2_5_Ohm = dlmread('./Data/20RMS_Voltage_output_2.5_Ohm.CSV', ',', 1, 0);

t_20_RMS_2_5_Ohm = data_20_RMS_2_5_Ohm(:, 1);
t_20_RMS_2_5_Ohm = t_20_RMS_2_5_Ohm - t_20_RMS_2_5_Ohm(1);
V_20_RMS_2_5_Ohm = data_20_RMS_2_5_Ohm(:, 2);
figure;
plot(t_20_RMS_2_5_Ohm(1:130256), V_20_RMS_2_5_Ohm(1:130256));
title("2.5 Ohm Load V_{\textrm{in}} = 20 VRMS")
print -dpng 'ENG306_Design_2.5_Ohm_Load_V_in_20_VRMS.png'

[V_ripple_20_RMS_2_5_Ohm, V_ripple_percent_20_RMS_2_5_Ohm, V_min_20_RMS_2_5_Ohm, V_max_20_RMS_2_5_Ohm, V_mean_20_RMS_2_5_Ohm] = voltage_data(t_20_RMS_2_5_Ohm, V_20_RMS_2_5_Ohm);
sprintf("V_ripple_20_RMS_2_5_Ohm = %fmV\n", V_ripple_20_RMS_2_5_Ohm*1e3)
sprintf("V_ripple_percent_20_RMS_2_5_Ohm = %f%%\n", V_ripple_percent_20_RMS_2_5_Ohm)
sprintf("V_min_20_RMS_2_5_Ohm = %fV\n", V_min_20_RMS_2_5_Ohm)
sprintf("V_max_20_RMS_2_5_Ohm = %fV\n", V_max_20_RMS_2_5_Ohm)
sprintf("V_mean_20_RMS_2_5_Ohm = %fV\n", V_mean_20_RMS_2_5_Ohm)
#+END_SRC

#+RESULTS:
#+begin_example
ans = NL_V_ripple = 25.390000mV
ans = NL_V_ripple_percent = 0.212747%
ans = NL_V_min = 11.921480V
ans = NL_V_max = 11.946870V
ans = NL_V_mean = 11.934354V
ans =
ans = V_ripple_22_Ohm = 35.150000mV
ans = V_ripple_percent_22_Ohm = 0.295837%
ans = V_min_22_Ohm = 11.864840V
ans = V_max_22_Ohm = 11.899990V
ans = V_mean_22_Ohm = 11.881539V
ans =
ans = V_ripple_2_5_Ohm = 293.000000mV
ans = V_ripple_percent_2_5_Ohm = 2.484134%
ans = V_min_2_5_Ohm = 11.648800V
ans = V_max_2_5_Ohm = 11.941800V
ans = V_mean_2_5_Ohm = 11.794855V
ans =
ans = V_ripple_23_RMS_25_Ohm = 41.020000mV
ans = V_ripple_percent_23_RMS_25_Ohm = 0.344099%
ans = V_min_23_RMS_25_Ohm = 11.899990V
ans = V_max_23_RMS_25_Ohm = 11.941010V
ans = V_mean_23_RMS_25_Ohm = 11.920997V
ans =
ans = V_ripple_20_RMS_2_5_Ohm = 10644.500000mV
ans = V_ripple_percent_20_RMS_2_5_Ohm = 116.908520%
ans = V_min_20_RMS_2_5_Ohm = 1.258200V
ans = V_max_20_RMS_2_5_Ohm = 11.902700V
ans = V_mean_20_RMS_2_5_Ohm = 9.104982V
#+end_example

\newpage
* Appendix D - Harmonics Plot

#+BEGIN_SRC octave :exports code :results output :session HARMONICS :eval no
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
 set(0, "DefaultLineLineWidth", 2);
 set(0, "DefaultAxesFontSize", 25);
 warning('off');
end

data = dlmread('./Data/20RMS_Voltage_output_2.5_Ohm.CSV', ',', 1, 0);
t = data(:, 1);
t = t - t(1);
V = data(:, 2);

Fs = 1/(t(2) - t(1));
N = length(V);
Y = fft(V);
P2 = abs(Y/N);
P1 = P2(1:N/2+1);
P1(2:end-1) = 2*P1(2:end-1);
M = P1(3);
P1 = P1./M;
f = Fs*(0:(N/2))/N;

figure;
plot(f, P1);
title('Amplitude Spectrum of V(t)');
xlabel('Frequency (f) [Hz]');
ylabel('|V(f)|');
xlim([0, 500])
ylim([0, 3])
grid on;
print -dpng 'ENG306_Design_Harmonics.png'
#+END_SRC

#+RESULTS:

\newpage
* Appendix E - Efficiency Plot Code
#+BEGIN_SRC octave :exports both :results output :session EFF :eval no
clc;
clear;
close all;

if exist('OCTAVE_VERSION', 'builtin')
 set(0, "DefaultLineLineWidth", 2);
 set(0, "DefaultAxesFontSize", 25);
 warning('off');
end

V = [32, 29, 26, 23, 20];
eff = [70.1, 70.7, 71.7, 71.2, 74.2];

plot(V, eff, '-o');
xlabel('V_{in,rms} (V)');
ylabel('Efficiency (%)');
title('Efficiency of Converter vs Input Voltage');
grid on;
print -dpng 'ENG306_Design_Efficency_Plot.png'
#+END_SRC

#+RESULTS:

\newpage
* Bibliography
\printbibliography


